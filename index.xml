<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kokatsu's blog</title><link>https://kokatsu.github.io/</link><description>Recent content on kokatsu's blog</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 30 Oct 2022 21:58:58 +0900</lastBuildDate><atom:link href="https://kokatsu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>AHC015参加記</title><link>https://kokatsu.github.io/posts/ahc015/</link><pubDate>Sun, 30 Oct 2022 21:58:58 +0900</pubDate><guid>https://kokatsu.github.io/posts/ahc015/</guid><description>490位 kokatsuさんのトヨタ自動車 プログラミングコンテスト2022（AtCoder Heuristic Contest 015）での成績：490位
パフォーマンス：1073相当
レーティング：780→866 (+86) :)#AtCoder #トヨタ自動車プログラミングコンテスト2022（AtCoderHeuristicContest015） https://t.co/q7WcNFYjGH 入緑！！！！！
&amp;mdash; kokatsu (@kokatsu_) October 30, 2022 問題のリンク
考えたこと ~1:37 (28M) ローカル版のツールのlib.rsを見ながらキャンディーの移動とスコアを計算する関数をD言語に移植。 キャンディーを受け取る毎に4方向へ傾けた際に1番スコアが高い方向に傾ける。
~2:59 (53M) 上記のコードを乱数を用いて変更を加えたが、得点が上がらなかった。 ビジュアライザを手で操作していると、1つの味を箱の1辺に集めていけば得点が上がりそうだとわかった。 とりあえず、最初に受け取る味のキャンディーの場合下に、それ以外のキャンディーの場合は右に傾ける解法で提出。 得点が53Mまで上がった。
~3:07 (61M) 下に傾けるキャンディーの味を最初に受け取る味から1番数が多い味に変更することで61Mまで上がった。
~4:00 1番数の多い味のキャンディーの場合下に傾けていき、下にキャンディーが溜まった場合に上以外の3方向で1番スコアが高くなる方向に傾けていく方針で実装。 しかし、思ったように得点が上がらない。 最初に提出していたコード内のキャンディーを入れる位置を求める関数が正しい位置を返していないことがわかった。 このミスに気づくのに30分以上費やしてしまった。
Coord findCoordToPut(long[N][] mat, long num) { Coord ret; long cnt; foreach (i; 0 .. N) { foreach (j; 0 .. N) { if (mat[i][j] == 0) ++cnt; if (cnt &amp;gt;= num) ret.</description></item><item><title>ABC274参加記</title><link>https://kokatsu.github.io/posts/abc274/</link><pubDate>Sun, 23 Oct 2022 01:10:09 +0900</pubDate><guid>https://kokatsu.github.io/posts/abc274/</guid><description>4完2ペナ93分 2289位
kokatsuさんのキーエンスプログラミングコンテスト2022（AtCoder Beginner Contest 274）での成績：2289位
パフォーマンス：975相当
レーティング：1267→1240 (-27) :(#AtCoder #キーエンスプログラミングコンテスト2022（ABC274） https://t.co/lZV1NNlva1 緑が近くなってきた。。。
&amp;mdash; kokatsu (@kokatsu_) October 22, 2022 A問題 D言語のreal型の精度を信じて提出。
import std; void main() { real A, B; readf(&amp;#34;%f %f\n&amp;#34;, A, B); real res = B / A; writefln(&amp;#34;%.3f&amp;#34;, res); } B問題 1行ごとにマスを読み込み、箱が置かれている列をカウントする。
import std; void main() { int H, W; readf(&amp;#34;%d %d\n&amp;#34;, H, W); auto res = new int[](W); foreach (_; 0 .. H) { string C; readf(&amp;#34;%s\n&amp;#34;, C); foreach (i, c; C) { if (c == &amp;#39;#&amp;#39;) ++res[i]; } } writefln(&amp;#34;%(%s %)&amp;#34;, res); } C問題 番号$2i$と$2i+1$のアメーバは$A_{i}$の世代$+1$になるので、時系列順に処理していく。</description></item></channel></rss>